snippet algebra <T> pow(<T>, <T>)
	${1:int} pow($1 _a, LL _b)
	{
		$1 _r = 1${2: % MOD};
		while(_b)
		{
			if(_b&1) _r = _r * _a$2;
			_a = _a * _a$2;
			_b >>= 1;
		}
		return _r;
	}
	${3}
snippet pow
	${1:int} pow($1 _a, LL _b)
	{
		$1 _r = 1${2: % MOD};
		while(_b)
		{
			if(_b&1) _r = _r * _a$2;
			_a = _a * _a$2;
			_b >>= 1;
		}
		return _r;
	}
	${3}
snippet algebra <T> phi(<T>)
	${1:int} phi($1 _n)
	{
		$1 _res = _n, _i;
		for(_i=2; _i*_i<=_n; ++_i)
			if(_n % _i == 0)
			{
				while(_n % _i == 0) _n /= _i;
				_res -= _res / _i;
			}
		if(_n > 1) _res -= _res / _n;
		return _res;
	}
	${2}
snippet phi
	${1:int} phi($1 _n)
	{
		$1 _res = _n, _i;
		for(_i=2; _i*_i<=_n; ++_i)
			if(_n % _i == 0)
			{
				while(_n % _i == 0) _n /= _i;
				_res -= _res / _i;
			}
		if(_n > 1) _res -= _res / _n;
		return _res;
	}
	${2}
snippet algebra <T> inverse(<T>, <T>)
	${2:gcdex}
	${1:int} inverse($1 _n, $1 _m)
	{
		$1 _x, _y;
		$1 _g = gcdex(_n, _m, _x, _y);
		if(_g != 1) return -1;
		else return (_x % _m + _m) % _m;
	}
snippet inverse
	${2:gcdex}
	${1:int} inverse($1 _n, $1 _m)
	{
		$1 _x, _y;
		$1 _g = gcdex(_n, _m, _x, _y);
		if(_g != 1) return -1;
		else return (_x % _m + _m) % _m;
	}
snippet algebra void inverse_all(int, vector<int>)
	void inverse_all(int _m, vector<int> &_v)
	{
		_v[1] = 1;
		for(int _i=2; _i < _m; ++_i)
			_v[_i] = (_m - (_m / _i) * _v[_m % _i] % _m) % _m;
	}
	${1}
snippet inverse_all
	void inverse_all(int _m, vector<int> &_v)
	{
		_v[1] = 1;
		for(int _i=2; _i < _m; ++_i)
			_v[_i] = (_m - (_m / _i) * _v[_m % _i] % _m) % _m;
	}
	${1}
snippet algebra <T> gcd(<T>, <T>)
	${1:int} gcd($1 _a, $1 _b)
	{
		if(_a<0) _a=-_a;
		if(_b<0) _b=-_b;
		while(_a!=0 && _b!=0) if(_a > _b) _a%=_b; else _b%=_a;
		return _a+_b;
	}
	${2}
snippet gcd
	${1:int} gcd($1 _a, $1 _b)
	{
		if(_a<0) _a=-_a;
		if(_b<0) _b=-_b;
		while(_a!=0 && _b!=0) if(_a > _b) _a%=_b; else _b%=_a;
		return _a+_b;
	}
	${2}
snippet algebra <T> lcm(<T>, <T>)
	${2:gcd}
	${1:int} lcm($1 _a, $1 _b)
	{
		return _a / gcd(_a, _b) * _b;
	}
snippet lcm
	${2:gcd}
	${1:int} lcm($1 _a, $1 _b)
	{
		return _a / gcd(_a, _b) * _b;
	}
snippet algebra <T> gcdex(<T>, <T>, <T> &, <T> &)
	${1:int} gcdex($1 _a, $1 _b, $1 &_x, $1 &_y)
	{
		$1 _r, _q, _x0, _y0, _x1, _y1;
		_y1=_x=_x0=1;
		_x1=_y=_y0=0;
		while(_b!=0){
			_q = _a/_b;
			_r = _a-_q*_b;
			if(_r!=0){
				_x = _x0-_q*_x1;
				_y = _y0-_q*_y1;
				_x0 = _x1; _y0 = _y1;
				_x1 = _x; _y1 = _y;
			}
			_a = _b; _b = _r;
		}
		if(_a<0) {_a=-_a; _x=-_x; _y=-_y;}
		return _a;
	}
	${2}
snippet gcdex
	${1:int} gcdex($1 _a, $1 _b, $1 &_x, $1 &_y)
	{
		$1 _r, _q, _x0, _y0, _x1, _y1;
		_y1=_x=_x0=1;
		_x1=_y=_y0=0;
		while(_b!=0){
			_q = _a/_b;
			_r = _a-_q*_b;
			if(_r!=0){
				_x = _x0-_q*_x1;
				_y = _y0-_q*_y1;
				_x0 = _x1; _y0 = _y1;
				_x1 = _x; _y1 = _y;
			}
			_a = _b; _b = _r;
		}
		if(_a<0) {_a=-_a; _x=-_x; _y=-_y;}
		return _a;
	}
	${2}
snippet algebra void getDivisors(<T>, vector<T> &)
	void getDivisors(${1:int} _n, vector<$1> &_r)
	{
		$1 _sq = (int)sqrt(_n+.0), _i;
		for(_i=1; _i<=_sq; ++_i)
			if(_n%_i==0)
				_r.push_back(_i);
		for(_i=(int)_r.size()-(_sq*_sq==_n)-1;_i>=0;--_i)
			_r.push_back(_n/_r[_i]);
	}
snippet getDivisors
	void getDivisors(${1:int} _n, vector<$1> &_r)
	{
		$1 _sq = (int)sqrt(_n+.0), _i;
		for(_i=1; _i<=_sq; ++_i)
			if(_n%_i==0)
				_r.push_back(_i);
		for(_i=(int)_r.size()-(_sq*_sq==_n)-1;_i>=0;--_i)
			_r.push_back(_n/_r[_i]);
	}
snippet algebra void factorize(<T>, vector<T> &)
	void factorize(${1:int} _n, vector<$1> _r)
	{
		$1 _x;
		for(_x=2; _n>1;)
		{
			while(_n%_x==0)
			{
				_r.push_back(_x);
				_n/=_x;
			}
			_x += 1 + (_x>2);
			if(_x*_x>_n) _x=_n;
		}
	}
snippet factorize
	void factorize(${1:int} _n, vector<$1> _r)
	{
		$1 _x;
		for(_x=2; _n>1;)
		{
			while(_n%_x==0)
			{
				_r.push_back(_x);
				_n/=_x;
			}
			_x += 1 + (_x>2);
			if(_x*_x>_n) _x=_n;
		}
	}
snippet algebra void eratosfen(vector<int> &)
	void eratosfen(vector<int> &_m)
	{
		int _n = _m.size();
		for(int _i=2; _i < _n; ++_i) _m[_i] = 1;
		_m[0] = _m[1] = 0;
		for(int _i=2; _i * 1LL * _i < _n; ++_i)
			if(_m[i])
				for(int _j=_i*_i; _j<_n; _j+=_i)
					_m[_j] = 0;
	}
	${2}
snippet eratosfen
	void eratosfen(vector<int> &_m)
	{
		int _n = _m.size();
		for(int _i=2; _i < _n; ++_i) _m[_i] = 1;
		_m[0] = _m[1] = 0;
		for(int _i=2; _i * 1LL * _i < _n; ++_i)
			if(_m[i])
				for(int _j=_i*_i; _j<_n; _j+=_i)
					_m[_j] = 0;
	}
	${2}
snippet algebra <T> fibonacci(<T2>, <T>)
	${1:int} fibonacci(${2:int} _n, $1 _mod=0)
	{
		$1 _r11=1, _r12=0, _r21=0, _r22=1;
		$1 _a1=0, _a2=1, _a3=1;
		$1 _t11, _t12, _t21, _t22;
		while(_n){
			if(_n&1)
			{
				_t11 = (_r11 * _a1 + _r12 * _a2) ${3:% _mod};
				_t12 = (_r11 * _a2 + _r12 * _a3) $3;
				_t21 = (_r21 * _a1 + _r22 * _a2) $3;
				_t22 = (_r21 * _a2 + _r22 * _a3) $3;

				_r11 = _t11; _r12 = _t12; _r21 = _t21; _r22 = _t22;
			}
			_t11 = (_a1 * _a1 + _a2 * _a2) $3;
			_t12 = (_a1 * _a2 + _a2 * _a3) $3;
			_t22 = (_a2 * _a2 + _a3 * _a3) $3;
		
			_a1 = _t11; _a2 = _t12; _a3 = _t22;
		
			_n >>= 1;
		}
		return _r21;
	}
	${4}
snippet fibonacci
	${1:int} fibonacci(${2:int} _n, $1 _mod=0)
	{
		$1 _r11=1, _r12=0, _r21=0, _r22=1;
		$1 _a1=0, _a2=1, _a3=1;
		$1 _t11, _t12, _t21, _t22;
		while(_n){
			if(_n&1)
			{
				_t11 = (_r11 * _a1 + _r12 * _a2) ${3:% _mod};
				_t12 = (_r11 * _a2 + _r12 * _a3) $3;
				_t21 = (_r21 * _a1 + _r22 * _a2) $3;
				_t22 = (_r21 * _a2 + _r22 * _a3) $3;

				_r11 = _t11; _r12 = _t12; _r21 = _t21; _r22 = _t22;
			}
			_t11 = (_a1 * _a1 + _a2 * _a2) $3;
			_t12 = (_a1 * _a2 + _a2 * _a3) $3;
			_t22 = (_a2 * _a2 + _a3 * _a3) $3;
		
			_a1 = _t11; _a2 = _t12; _a3 = _t22;
		
			_n >>= 1;
		}
		return _r21;
	}
	${4}
snippet algebra int grey(int)
	int grey(int _n)
	{
		return _n ^ (_n >> 1);
	}
	${1}
snippet grey
	int grey(int _n)
	{
		return _n ^ (_n >> 1);
	}
	${1}
snippet algebra int reverse_grey(int)
	int reverse_grey(int _code)
	{
		int _n = 0;
		for(; _code; _code >>= 1)
			_n ^= _code;
		return _n;
	}
	${1}
snippet reverse_grey
	int reverse_grey(int _code)
	{
		int _n = 0;
		for(; _code; _code >>= 1)
			_n ^= _code;
		return _n;
	}
	${1}
snippet algebra int factmod(<T>, int)
	int factmod(${1:int} _n, int _MOD)
	{
		int _res = 1;
		while(_n > 1)
		{
			_res = (_res * (((_n/_MOD)&1) ? _MOD-1 : 1)) % _MOD;
			for(int _i=2; _i <= _n % _MOD; ++_i)
				_res = (_res ${2:* 1LL }* _i) % _MOD;
			_n /= _MOD;
		}
		return _res % _MOD;
	}
	${3}
snippet factmod
	int factmod(${1:int} _n, int _MOD)
	{
		int _res = 1;
		while(_n > 1)
		{
			_res = (_res * (((_n/_MOD)&1) ? _MOD-1 : 1)) % _MOD;
			for(int _i=2; _i <= _n % _MOD; ++_i)
				_res = (_res ${2:* 1LL }* _i) % _MOD;
			_n /= _MOD;
		}
		return _res % _MOD;
	}
	${3}
snippet algebra bool isPrime(<T>)
	bool isPrime(${1:int} _n)
	{
		if(_n<2 || (_n>2 && _n%2==0) || (_n>3 && _n%6%4!=1)) return false;
		for($1 _i=3; _i*_i<=_n; _i+=2)
			if(_n%_i==0) return false;
		return true;
	}
snippet isPrime
	bool isPrime(${1:int} _n)
	{
		if(_n<2 || (_n>2 && _n%2==0) || (_n>3 && _n%6%4!=1)) return false;
		for($1 _i=3; _i*_i<=_n; _i+=2)
			if(_n%_i==0) return false;
		return true;
	}
