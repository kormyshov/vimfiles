# =============================== string ======================

snippet string void suffix_array(const string &, vector<int> &)
	void suffix_array(const string &_s, vector<int> &_p)
	{
		int _i, _cl, _n = (int)_s.size();

		const int _MAX_N = ${1:100500};
		const int _MAX_Alphabet = ${2:26};

		int _cnt[_MAX_N], _c[_MAX_N], _pn[_MAX_N], _cn[_MAX_N];

		memset(_cnt, 0, sizeof(_cnt));
		for(_i=0; _i<_n; ++_i) ++_cnt[_s[_i]${3:-'a'}];
		for(_i=1; _i<_MAX_Alphabet; ++_i) _cnt[_i] += _cnt[_i-1];
		for(_i=0; _i<_n; ++_i) _p[--_cnt[_s[_i]$3]] = _i;
		_c[_p[0]] = 0;
		_cl = 1;
		for(_i=1; _i<_n; ++_i)
		{
			if(_s[_p[_i]] != _s[_p[_i-1]]) ++_cl;
			_c[_p[_i]] = _cl-1;
		}
		for(int _h=0; (1<<_h)<_n; ++_h)
		{
			for(_i=0; _i<_n; ++_i)
			{
				_pn[_i] = _p[_i] - (1<<_h);
				if(_pn[_i] < 0) _pn[_i] += _n;
			}
			memset(_cnt, 0, sizeof(_cnt));
			for(_i=0; _i<_n; ++_i) ++_cnt[_c[_pn[_i]]];
			for(_i=1; _i<_cl; ++_i) _cnt[_i] += _cnt[_i-1];
			for(_i=_n-1; _i>=0; --_i) _p[--_cnt[_c[_pn[_i]]]] = _pn[_i];
			_cn[_p[0]] = 0;
			_cl = 1;
			for(_i=1; _i<_n; ++_i)
			{
				int _mid1 = (_p[_i]   + (1<<_h)) % _n;
				int _mid2 = (_p[_i-1] + (1<<_h)) % _n;
				if(_c[_p[_i]] != _c[_p[_i-1]] || _c[_mid1] != _c[_mid2]) ++_cl;
				_cn[_p[_i]] = _cl-1;
			}
			memcpy(_c, _cn, sizeof(_c));
		}
	}
	${4}
snippet suffix_array
	void suffix_array(const string &_s, vector<int> &_p)
	{
		int _i, _cl, _n = (int)_s.size();

		const int _MAX_N = ${1:100500};
		const int _MAX_Alphabet = ${2:26};

		int _cnt[_MAX_N], _c[_MAX_N], _pn[_MAX_N], _cn[_MAX_N];

		memset(_cnt, 0, sizeof(_cnt));
		for(_i=0; _i<_n; ++_i) ++_cnt[_s[_i]${3:-'a'}];
		for(_i=1; _i<_MAX_Alphabet; ++_i) _cnt[_i] += _cnt[_i-1];
		for(_i=0; _i<_n; ++_i) _p[--_cnt[_s[_i]$3]] = _i;
		_c[_p[0]] = 0;
		_cl = 1;
		for(_i=1; _i<_n; ++_i)
		{
			if(_s[_p[_i]] != _s[_p[_i-1]]) ++_cl;
			_c[_p[_i]] = _cl-1;
		}
		for(int _h=0; (1<<_h)<_n; ++_h)
		{
			for(_i=0; _i<_n; ++_i)
			{
				_pn[_i] = _p[_i] - (1<<_h);
				if(_pn[_i] < 0) _pn[_i] += _n;
			}
			memset(_cnt, 0, sizeof(_cnt));
			for(_i=0; _i<_n; ++_i) ++_cnt[_c[_pn[_i]]];
			for(_i=1; _i<_cl; ++_i) _cnt[_i] += _cnt[_i-1];
			for(_i=_n-1; _i>=0; --_i) _p[--_cnt[_c[_pn[_i]]]] = _pn[_i];
			_cn[_p[0]] = 0;
			_cl = 1;
			for(_i=1; _i<_n; ++_i)
			{
				int _mid1 = (_p[_i]   + (1<<_h)) % _n;
				int _mid2 = (_p[_i-1] + (1<<_h)) % _n;
				if(_c[_p[_i]] != _c[_p[_i-1]] || _c[_mid1] != _c[_mid2]) ++_cl;
				_cn[_p[_i]] = _cl-1;
			}
			memcpy(_c, _cn, sizeof(_c));
		}
	}
	${4}
snippet string void pfun(const string &, vector<int> &)
	void pfun(const string &_s, vector<int> &_v)
	{
		int _j, _n = (int)_s.size();
		_v[0] = 0;
		for(int _i=1; _i<_n; ++_i)
		{
			_j = _v[_i-1];
			while(_j > 0 && _s[_i] != _s[_j]) _j = _v[_j-1];
			if(_s[_i] == _s[_j]) ++_j;
			_v[_i] = _j;
		}
	}
	${1}
snippet pfun
	void pfun(const string &_s, vector<int> &_v)
	{
		int _j, _n = (int)_s.size();
		_v[0] = 0;
		for(int _i=1; _i<_n; ++_i)
		{
			_j = _v[_i-1];
			while(_j > 0 && _s[_i] != _s[_j]) _j = _v[_j-1];
			if(_s[_i] == _s[_j]) ++_j;
			_v[_i] = _j;
		}
	}
	${1}
snippet string void zfun(const string &, vector<int> &)
	void zfun(const string &_s, vector<int> &_v)
	{
		int _n = (int)_s.size();
		_v[0] = 0;
		for(int _i=1, _l=0, _r=0; _i<_n; ++_i)
		{
			if(_i <= _r) _v[_i] = min(_r-_i+1, _v[_i-_l]);
			while(_i+_v[_i] < _n && _s[_v[_i]] == _s[_i+_v[_i]]) ++_v[_i];
			if(_i+_v[_i]-1 > _r)
			{
				_l = _i;
				_r = _i+_v[_i]-1;
			}
		}
	}
	${1}
snippet zfun
	void zfun(const string &_s, vector<int> &_v)
	{
		int _n = (int)_s.size();
		_v[0] = 0;
		for(int _i=1, _l=0, _r=0; _i<_n; ++_i)
		{
			if(_i <= _r) _v[_i] = min(_r-_i+1, _v[_i-_l]);
			while(_i+_v[_i] < _n && _s[_v[_i]] == _s[_i+_v[_i]]) ++_v[_i];
			if(_i+_v[_i]-1 > _r)
			{
				_l = _i;
				_r = _i+_v[_i]-1;
			}
		}
	}
	${1}
# =============================== BI ==========================

snippet BI
	struct BI
	{
		int d[BI_MAX_SIZE];
		int l;
	};
	
	void scanf(BI &a)
	{
		char s[BI_MAX_SIZE * 9];
		cin>>s;
		a.l = a.d[0] = 0;
		for(int i=strlen(s); i>0; i-=9)
		{
			s[i] = 0;
			a.d[a.l++] = atoi( ( i>=9 ? s+i-9 : s ) );
		}
	}
	
	void printf(BI &a)
	{
		printf("%d", a.l ? a.d[a.l-1] : 0);
		for(int i=a.l-2; i>=0; --i)
			printf("%09d", a.d[i]);
	}
	
	void sum(BI &a, BI &b, BI &c)
	{
		int i, p = 0, m = max(a.l, b.l);
		memset(c.d, 0, sizeof(c.d));
		for(i=0; i<m || p; ++i)
		{
			c.d[i] = p + ( i<a.l ? a.d[i] : 0 ) + ( i<b.l ? b.d[i] : 0 );
			p = c.d[i] >= BI_BASE;
			if(p) c.d[i] -= BI_BASE;
		}
		c.l = i;
	}
	
	void sub(BI &a, BI &b, BI &c)
	{
		int i, p = 0;
		for(i=0; i<a.l || p; ++i)
		{
			c.d[i] = a.d[i] - p - ( i<b.l ? b.d[i] : 0 );
			p = c.d[i] < 0;
			if(p) c.d[i] += BI_BASE;
		}
		c.l = i;
		while(c.l > 1 && c.d[c.l-1] == 0) --c.l;
	}
	
	void mult(BI &a, int b, BI &c, int d = 0)
	{
		int i, p = 0;
		LL t;
		for(i=0; i<d; ++i) c.d[i] = 0;
		for(i=0; i<a.l || p; ++i)
		{
			t = a.d[i] * 1LL * b + p;
			p = int(t / BI_BASE);
			c.d[i + d] = int(t - p * 1LL * BI_BASE);
		}
		c.l = i + d;
	}
	
	void put(int a, BI &b)
	{
		b.l = 1;
		b.d[0] = a;
	}
	
	void copy(BI &a, BI &b)
	{
		a.l = b.l;
		memcpy(a.d, b.d, sizeof(b.d));
	}
	
	void mult(BI &a, BI &b, BI &c)
	{
		int i;
		BI t, tmp;
		put(0, c);
		for(i=0; i<b.l; ++i)
		{
			mult(a, b.d[i], t, i);
			sum(t, c, tmp);
			copy(c, tmp);
		}
	}
	
	void div(BI &a, int b, BI &c)
	{
		int i, p = 0;
		LL t;
		for(i = a.l-1; i>=0; --i)
		{
			t = a.d[i] + p * 1LL * BI_BASE;
			c.d[i] = int(t / b);
			p = int(t - c.d[i] * 1LL * b);
		}
		c.l = a.l;
		while(c.l > 1 && c.d[a.l-1] == 0) --c.l;
	}
	${1}
# =============================== cpp4cf ======================

snippet cpp4cf test
	/* Test on
	${1}
	// ${2}
	*/
	${3}
snippet test
	/* Test on
	${1}
	// ${2}
	*/
	${3}
# =============================== algebra =====================

snippet algebra <T> pow(<T>, <T>)
	${1:int} pow($1 _a, LL _b)
	{
		$1 _r = 1${2: % MOD};
		while(_b)
		{
			if(_b&1) _r = _r * _a$2;
			_a = _a * _a$2;
			_b >>= 1;
		}
		return _r;
	}
	${3}
snippet pow
	${1:int} pow($1 _a, LL _b)
	{
		$1 _r = 1${2: % MOD};
		while(_b)
		{
			if(_b&1) _r = _r * _a$2;
			_a = _a * _a$2;
			_b >>= 1;
		}
		return _r;
	}
	${3}
snippet algebra <T> phi(<T>)
	${1:int} phi($1 _n)
	{
		$1 _res = _n, _i;
		for(_i=2; _i*_i<=_n; ++_i)
			if(_n % _i == 0)
			{
				while(_n % _i == 0) _n /= _i;
				_res -= _res / _i;
			}
		if(_n > 1) _res -= _res / _n;
		return _res;
	}
	${2}
snippet phi
	${1:int} phi($1 _n)
	{
		$1 _res = _n, _i;
		for(_i=2; _i*_i<=_n; ++_i)
			if(_n % _i == 0)
			{
				while(_n % _i == 0) _n /= _i;
				_res -= _res / _i;
			}
		if(_n > 1) _res -= _res / _n;
		return _res;
	}
	${2}
snippet algebra <T> inverse(<T>, <T>)
	${2:gcdex}
	${1:int} inverse($1 _n, $1 _m)
	{
		$1 _x, _y;
		$1 _g = gcdex(_n, _m, _x, _y);
		if(_g != 1) return -1;
		else return (_x % _m + _m) % _m;
	}
snippet inverse
	${2:gcdex}
	${1:int} inverse($1 _n, $1 _m)
	{
		$1 _x, _y;
		$1 _g = gcdex(_n, _m, _x, _y);
		if(_g != 1) return -1;
		else return (_x % _m + _m) % _m;
	}
snippet algebra void inverse_all(int, vector<int>)
	void inverse_all(int _m, vector<int> &_v)
	{
		_v[1] = 1;
		for(int _i=2; _i < _m; ++_i)
			_v[_i] = (_m - (_m / _i) * _v[_m % _i] % _m) % _m;
	}
	${1}
snippet inverse_all
	void inverse_all(int _m, vector<int> &_v)
	{
		_v[1] = 1;
		for(int _i=2; _i < _m; ++_i)
			_v[_i] = (_m - (_m / _i) * _v[_m % _i] % _m) % _m;
	}
	${1}
snippet algebra <T> gcd(<T>, <T>)
	${1:int} gcd($1 _a, $1 _b)
	{
		$1 _t;
		while(_a)
		{
			_t = _b % _a;
			_b = _a;
			_a = _t;
		}
		return _b;
	}
	${2}
snippet gcd
	${1:int} gcd($1 _a, $1 _b)
	{
		$1 _t;
		while(_a)
		{
			_t = _b % _a;
			_b = _a;
			_a = _t;
		}
		return _b;
	}
	${2}
snippet algebra <T> lcm(<T>, <T>)
	${2:gcd}
	${1:int} lcm($1 _a, $1 _b)
	{
		return _a / gcd(_a, _b) * _b;
	}
snippet lcm
	${2:gcd}
	${1:int} lcm($1 _a, $1 _b)
	{
		return _a / gcd(_a, _b) * _b;
	}
snippet algebra <T> gcdex(<T>, <T>, <T> &, <T> &)
	${1:int} gcdex($1 _a, $1 _b, $1 &_x, $1 &_y)
	{
		if(!_a)
		{
			_x = 0;
			_y = 1;
			return _b;
		}
		$1 _x1, _y1;
		$1 _d = gcdex(_b % _a, _a, _x1, _y1);
		_x = _y1 - (_b / _a) * _x1;
		_y = _x1;
		return _d;
	}
	${2}
snippet gcdex
	${1:int} gcdex($1 _a, $1 _b, $1 &_x, $1 &_y)
	{
		if(!_a)
		{
			_x = 0;
			_y = 1;
			return _b;
		}
		$1 _x1, _y1;
		$1 _d = gcdex(_b % _a, _a, _x1, _y1);
		_x = _y1 - (_b / _a) * _x1;
		_y = _x1;
		return _d;
	}
	${2}
snippet algebra void eratosfen(int, <T> [])
	void eratosfen(vector<int> &_m)
	{
		int _n = _m.size();
		for(int _i=2; _i < _n; ++_i) _m[_i] = 1;
		_m[0] = _m[1] = 0;
		for(int _i=2; _i * 1LL * _i < _n; ++_i)
			if(_m[i])
				for(int _j=_i*_i; _j<_n; _j+=_i)
					_m[_j] = 0;
	}
	${2}
snippet eratosfen
	void eratosfen(vector<int> &_m)
	{
		int _n = _m.size();
		for(int _i=2; _i < _n; ++_i) _m[_i] = 1;
		_m[0] = _m[1] = 0;
		for(int _i=2; _i * 1LL * _i < _n; ++_i)
			if(_m[i])
				for(int _j=_i*_i; _j<_n; _j+=_i)
					_m[_j] = 0;
	}
	${2}
snippet algebra <T> fibonacci(<T2>, <T>)
	${1:int} fibonacci(${2:int} _n, $1 _mod=0)
	{
		$1 _r11=1, _r12=0, _r21=0, _r22=1;
		$1 _a1=0, _a2=1, _a3=1;
		$1 _t11, _t12, _t21, _t22;
		while(_n){
			if(_n&1)
			{
				_t11 = (_r11 * _a1 + _r12 * _a2) ${3:% _mod};
				_t12 = (_r11 * _a2 + _r12 * _a3) $3;
				_t21 = (_r21 * _a1 + _r22 * _a2) $3;
				_t22 = (_r21 * _a2 + _r22 * _a3) $3;

				_r11 = _t11; _r12 = _t12; _r21 = _t21; _r22 = _t22;
			}
			_t11 = (_a1 * _a1 + _a2 * _a2) $3;
			_t12 = (_a1 * _a2 + _a2 * _a3) $3;
			_t22 = (_a2 * _a2 + _a3 * _a3) $3;
		
			_a1 = _t11; _a2 = _t12; _a3 = _t22;
		
			_n >>= 1;
		}
		return _r21;
	}
	${4}
snippet fibonacci
	${1:int} fibonacci(${2:int} _n, $1 _mod=0)
	{
		$1 _r11=1, _r12=0, _r21=0, _r22=1;
		$1 _a1=0, _a2=1, _a3=1;
		$1 _t11, _t12, _t21, _t22;
		while(_n){
			if(_n&1)
			{
				_t11 = (_r11 * _a1 + _r12 * _a2) ${3:% _mod};
				_t12 = (_r11 * _a2 + _r12 * _a3) $3;
				_t21 = (_r21 * _a1 + _r22 * _a2) $3;
				_t22 = (_r21 * _a2 + _r22 * _a3) $3;

				_r11 = _t11; _r12 = _t12; _r21 = _t21; _r22 = _t22;
			}
			_t11 = (_a1 * _a1 + _a2 * _a2) $3;
			_t12 = (_a1 * _a2 + _a2 * _a3) $3;
			_t22 = (_a2 * _a2 + _a3 * _a3) $3;
		
			_a1 = _t11; _a2 = _t12; _a3 = _t22;
		
			_n >>= 1;
		}
		return _r21;
	}
	${4}
snippet algebra int grey(int)
	int grey(int _n)
	{
		return _n ^ (_n >> 1);
	}
	${1}
snippet grey
	int grey(int _n)
	{
		return _n ^ (_n >> 1);
	}
	${1}
snippet algebra int reverse_grey(int)
	int reverse_grey(int _code)
	{
		int _n = 0;
		for(; _code; _code >>= 1)
			_n ^= _code;
		return _n;
	}
	${1}
snippet reverse_grey
	int reverse_grey(int _code)
	{
		int _n = 0;
		for(; _code; _code >>= 1)
			_n ^= _code;
		return _n;
	}
	${1}
snippet algebra int factmod(<T>, int)
	int factmod(${1:int} _n, int _MOD)
	{
		int _res = 1;
		while(_n > 1)
		{
			_res = (_res * (((_n/_MOD)&1) ? _MOD-1 : 1)) % _MOD;
			for(int _i=2; _i <= _n % _MOD; ++_i)
				_res = (_res ${2:* 1LL }* _i) % _MOD;
			_n /= _MOD;
		}
		return _res % _MOD;
	}
	${3}
snippet factmod
	int factmod(${1:int} _n, int _MOD)
	{
		int _res = 1;
		while(_n > 1)
		{
			_res = (_res * (((_n/_MOD)&1) ? _MOD-1 : 1)) % _MOD;
			for(int _i=2; _i <= _n % _MOD; ++_i)
				_res = (_res ${2:* 1LL }* _i) % _MOD;
			_n /= _MOD;
		}
		return _res % _MOD;
	}
	${3}
