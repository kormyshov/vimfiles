snippet clique "max clique" !b
int n;
vector<LL> g;

int clique(LL cl, LL cand, LL out, int size = 0)
{
    int result = 0;
    LL candintersect = (1LL << n) - 1;
    for (int i = 0; i < n; ++i) if (cand & (1LL << i)) candintersect &= g[i];
    if (out & candintersect) return result;

    for (int i = 0; i < n; ++i) if (cand & (1LL << i)) {
        LL mask = 1LL << i;
        LL ncand = cand & g[i], nout = out & g[i];
        if (ncand == 0 && nout == 0)
            result = max(result, size + 1);
        else
            result = max(result, clique(cl | mask, ncand, nout, size + 1));
        cand = cand & ~mask;
        if (!cand) return result;
        out = out | mask;
    }
    return result;
}
$0
endsnippet
snippet Dijkstra "Dijkstra with sqrt" !b
vector<int> dijkstra_d, dijkstra_f, dijkstra_sqrt_d;
int dijkstra_sqrt_n;

void dijkstra_init(int v){
	dijkstra_sqrt_n = max(1., sqrt(N*0.5));
	dijkstra_sqrt_d.assign(N/dijkstra_sqrt_n+1, INF2);
	dijkstra_sqrt_d[v/dijkstra_sqrt_n] = 0;
}

int dijkstra_get(){
	int v = -1, i, t=0, dt;
	for(i=1;i<(int)dijkstra_sqrt_d.size();++i)
		if(dijkstra_sqrt_d[t] > dijkstra_sqrt_d[i]) t=i;
	int l = t*dijkstra_sqrt_n, r = min(l+dijkstra_sqrt_n, N);
	dt = dijkstra_sqrt_d[t];
	dijkstra_sqrt_d[t] = INF2;
	for(i=l; i<r; ++i)
		if(!dijkstra_f[i]){
		if(dt==dijkstra_d[i]) dijkstra_f[i]=1, --dt, v=i;
		else dijkstra_sqrt_d[t] = min(dijkstra_sqrt_d[t], dijkstra_d[i]);
	}
	return v;
}

vector<int> Dijkstra(int s){
	dijkstra_d.assign(N, INF2);
	dijkstra_f.assign(N, 0);
	dijkstra_d[s] = 0;
	dijkstra_init(s);
	int i, j, v, to, len;
	for(i=0;i<N;++i){
		v = dijkstra_get();
		if(v<0 || dijkstra_d[v] >= INF2) break;
		for(j=0; j<(int)g[v].size(); ++j){
			to = g[v][j].first;
			len = g[v][j].second;
			if(dijkstra_d[v] + len < dijkstra_d[to]){
				dijkstra_d[to] = dijkstra_d[v] + len;
				if(dijkstra_sqrt_d[to/dijkstra_sqrt_n] > dijkstra_d[to])
					dijkstra_sqrt_d[to/dijkstra_sqrt_n] = dijkstra_d[to];
			}
		}
	}
	return dijkstra_d;
}
endsnippet
snippet DijkstraHeap "Dijkstra with heap" !b
vector<int> dijkstra_heap, dijkstra_heap_p, dijkstra_d;

void dijkstra_pop(){
	dijkstra_heap_p[dijkstra_heap[1]] = 0;
	dijkstra_heap[1] = dijkstra_heap[dijkstra_heap[0]--];
	int t = dijkstra_heap[1], a = 1, mn;
	while(2*a <= dijkstra_heap[0]){
		mn = 2*a;
		if(mn+1<=dijkstra_heap[0] &&
		   dijkstra_d[dijkstra_heap[mn+1]] < dijkstra_d[dijkstra_heap[mn]])
			mn++;
		if(dijkstra_d[dijkstra_heap[mn]] < dijkstra_d[t]){
			dijkstra_heap[a] = dijkstra_heap[mn];
			dijkstra_heap_p[dijkstra_heap[a]] = a;
			a = mn;
		}else break;
	}
	dijkstra_heap[a] = t;
	dijkstra_heap_p[t] = a;
}

void dijkstra_relax(int v){
	if(dijkstra_heap_p[v] == 0)
		dijkstra_heap[++dijkstra_heap[0]] = v, dijkstra_heap_p[v] = dijkstra_heap[0];
	int a = dijkstra_heap_p[v];
	while(a>1)
		if(dijkstra_d[dijkstra_heap[a>>1]] > dijkstra_d[v]){
			dijkstra_heap[a] = dijkstra_heap[a>>1];
			dijkstra_heap_p[dijkstra_heap[a]] = a;
			a >>= 1;
		}else break;
	dijkstra_heap[a] = v;
	dijkstra_heap_p[v] = a;
}

vector<int> Dijkstra(int s){
	dijkstra_d.assign(N, INF2);
	dijkstra_d[s] = 0;
	dijkstra_heap.assign(N+1,0);
	dijkstra_heap[0] = 1;
	dijkstra_heap[1] = s;
	dijkstra_heap_p.assign(N, 0);
	dijkstra_heap_p[s] = 1;
	while(dijkstra_heap[0]){
		int v = dijkstra_heap[1];
		dijkstra_pop();
		for(int j=0;j<(int)g[v].size();++j){
			int to = g[v][j].first,
				len = g[v][j].second;
			if(dijkstra_d[v]+len < dijkstra_d[to]){
				dijkstra_d[to] = dijkstra_d[v] + len;
				dijkstra_relax(to);
			}
		}
	}
	return dijkstra_d;
}
endsnippet
snippet Floyd "Floyd inline" !b
for(int _floyd_k_=0; _floyd_k_<${1:n}; ++_floyd_k_)
	for(int _floyd_i_=0; _floyd_i_<$1; ++_floyd_i_)
		for(int _floyd_j_=0; _floyd_j_<$1; ++_floyd_j_)
			${2:mm}[_floyd_i_][_floyd_j_] = min($2[_floyd_i_][_floyd_j_],
							$2[_floyd_i_][_floyd_k_]+$2[_floyd_k_][_floyd_j_]);
endsnippet
